package cs673;

import hoten.geom.Point;
import hoten.voronoi.Center;
import hoten.voronoi.Corner;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Image;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Random;

import javax.imageio.ImageIO;

import org.apache.commons.math3.analysis.function.Sinc;
import org.apache.commons.math3.distribution.NormalDistribution;
import org.imgscalr.Scalr;
import org.imgscalr.Scalr.Method;

import jigl.image.ColorImage;
import jigl.image.ImageKernel;
import jigl.image.ImageNotSupportedException;
import jigl.image.ops.Convolve;
import util.Helper;
import util.ImageHelper;
import util.Range;
import static java.lang.System.out;

public class MapCreator
{
	static final double sizeMultiplyer = 1.0;
	static final int landBlurLevel = (int)(30 * sizeMultiplyer);
	static final int oceanBlurLevel = (int)(30 * sizeMultiplyer);
	static final double mountainElevationThreshold = 0.6;
	static final double hillElevationThreshold = 0.55;
	static final double treeScale = 1.0/4.0;
	static final int numSites = 12000;
	static final int numberOfTreesPerLocation = 3;
	static final Color riverColor = new Color(56, 48, 33);
	static final Color landBlurColor = new Color(119, 91, 36);
	
	private static Random r;

	public static void main(String[] args) throws IOException,
			ImageNotSupportedException
	{
		double startTime = System.currentTimeMillis();
		
		if (args.length > 1)
			out.println("usage: MapCreator.java [output_filename]");
		String outputFilename = "map.png";
		if (args.length > 0)
			outputFilename = args[0];

		//925444811518835L;
		final long seed = System.nanoTime();
        System.out.println("seed: " + seed);
        r = new Random(seed);

//		GraphImpl graph = GraphCreator.createGraph((int)(0.5*2048*sizeMultiplyer), (int)(0.5*1152*sizeMultiplyer),
//				numSites, r);
		GraphImpl graph = GraphCreator.createGraph((int)(2048*sizeMultiplyer), (int)(1152*sizeMultiplyer),
				numSites, r);

		markMountains(graph);

		// Draw mask for land vs ocean.
		out.println("Adding land.");
		BufferedImage landMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
		{
			Graphics2D g = landMask.createGraphics();
			graph.paint(g, false, false, true, true, false, false);
			//ImageIO.write(landMask, "png", new File("land_mask.png"));
		}

		BufferedImage map = null;
		{
			BufferedImage land = ImageIO.read(new File("assets" + File.separator
					+ "land.png"));
			land = ImageHelper.scale(land, graph.getWidth());
	
			// Combine land and ocean images.
			map = ImageHelper.maskWithColor(land, Color.black, landMask, false);
		}
		
		out.println("Creating coast lines.");
		BufferedImage coastlineMask = null;
		{
			coastlineMask = new BufferedImage(graph.getWidth(),
					graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY); // TODO see if this works.
			Graphics2D g = coastlineMask.createGraphics();
			graph.paint(g, false, false, false, false, true, false, Math.max(1, (int) sizeMultiplyer));
			//ImageIO.write(coastlineMask, "png", new File("coastline_mask.png"));
		}

		// Darken the land next to borders.
		out.println("Darkening land near shores.");
		{
			float[][] kernel = ImageHelper.createGaussianKernel(landBlurLevel);
			BufferedImage landBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
			ImageHelper.maximizeContrastGrayscale(landBlur);
			// Remove the land blur from the ocean side of the borders.
			landBlur = ImageHelper.maskWithColor(landBlur, Color.black, landMask, false);
			map = ImageHelper.maskWithColor(map, landBlurColor, landBlur, true);
			ImageIO.write(landBlur, "png", new File("land_blur.png"));
		}

		// Store the current version of the map for a background when drawing icons later.
		BufferedImage landBackground = ImageHelper.deepCopy(map);

		// Add rivers.
		out.println("Adding rivers.");
		{
			BufferedImage riverMask = new BufferedImage(graph.getWidth(),
					graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
			Graphics2D g = riverMask.createGraphics();
			// Draw rivers thin.
			graph.paint(g, false, false, false, false, false, true, sizeMultiplyer/2.0);
			map = ImageHelper.maskWithColor(map, riverColor, riverMask, true);
		}

		
		// Add hills.
		out.println("Adding hills.");
		addHills(graph, map, landBackground);
		
		// Add mountains.
		out.println("Adding mountains.");
		addMountains(graph, map, landBackground);
		
		// Add trees.
		out.println("Adding trees.");
		addTrees(graph, map, landBackground);
		
		
		out.println("Drawing ocean.");
		{
			BufferedImage ocean = ImageIO.read(new File("assets" + File.separator + "ocean.png"));
			ocean = ImageHelper.scale(ocean, graph.getWidth());
			// Needed for drawing text.
			landBackground = ImageHelper.combineWithMask(landBackground, ocean, landMask);
			
			map = ImageHelper.combineWithMask(map, ocean, landMask);
		}
		
		// Create waves in the ocean near borders.
		out.println("Adding waves to ocean.");
		{
			float[][] kernel = ImageHelper.createPositiveSincKernel(oceanBlurLevel, 1.0/sizeMultiplyer);
			BufferedImage oceanBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
			ImageHelper.maximizeContrastGrayscale(oceanBlur);
			// Remove the ocean blur from the land side of the borders.
			oceanBlur = ImageHelper.maskWithColor(oceanBlur, Color.black, landMask, true);
			ImageIO.write(oceanBlur, "png", new File("ocean_blur.png"));
			map = ImageHelper.maskWithColor(map, Color.black, oceanBlur, true);
		}
		
		// Draw mask for coast lines.
		map = ImageHelper.maskWithColor(map, Color.black, coastlineMask, true);
		landBackground = ImageHelper.maskWithColor(landBackground,  Color.black, coastlineMask, true);
		
		out.println("Adding text");
		TextDrawer textDrawer = new TextDrawer(sizeMultiplyer, landBackground);
		textDrawer.drawText(graph, map);
		
		ImageIO.write(map, "png", new File(outputFilename));
		
		double elapsedTime = System.currentTimeMillis() - startTime;
		System.out.println("Total time to generate map (in seconds): " + elapsedTime
				/ 1000.0);

		out.println("Done.");
	}
		
	private static void markMountains(GraphImpl graph)
	{
		for (Center c : graph.centers)
		{
			if (c.elevation > mountainElevationThreshold && !c.water
					&& !c.coast)
			{
				c.mountain = true;
			}
		}
	}
		
	private static void addMountains(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
	{
		
        Graphics g = map.getGraphics();
        BufferedImage mountain1 = ImageIO.read(new File("assets" + File.separator
				+ "mountain1.png"));
        BufferedImage mountain2 = ImageIO.read(new File("assets" + File.separator
				+ "mountain2.png"));
        BufferedImage mountain3 = ImageIO.read(new File("assets" + File.separator
				+ "mountain3.png"));
        BufferedImage mountain4 = ImageIO.read(new File("assets" + File.separator
				+ "mountain4.png"));
        BufferedImage mountain5 = ImageIO.read(new File("assets" + File.separator
				+ "mountain5.png"));
        List<BufferedImage> mountainImages = Arrays.asList(mountain1, mountain2, mountain3, mountain4,
        		mountain5);
       

        for (Center c : graph.centers)
        {
        	if (c.mountain)
        	{        		
        		// Find the center's size along the x axis.
	        	double cSize = findCenterWidth(c);
	           	
	           	if ((int)(cSize) > 0)
	           	{
		           	BufferedImage scaledMountain = ImageHelper.scale(mountainImages.get(r.nextInt(mountainImages.size())),
		           			(int)cSize);
		           	// Draw the image such that it is centered in the center of c.
		           	int x = (int) (c.loc.x - cSize/2);
		           	int y = (int) (c.loc.y - scaledMountain.getHeight()/2.0);
		        	
		        	//g.drawImage(scaledMountain, x, y, null);
		           	drawIconWithBackground(map, scaledMountain, land, x, y);
	           	}
	        }
        }
        
        g.dispose();
	}
		
	/**
	 * Draws the given image onto the map. Wherever the icon contains the color (175, 151, 102),
	 * the background image will be drawn instead.
	 * @param mapGraphics
	 * @param icon Will be mutated.
	 * @param background
	 */
	private static void drawIconWithBackground(BufferedImage map, BufferedImage icon, 
			BufferedImage background, int xLoc, int yLoc)
	{
		int r = 174;
		int g = 150;
		int b = 102;
    	
    	if (map.getWidth() != background.getWidth())
    		throw new IllegalArgumentException();
       	if (map.getHeight() != background.getHeight())
    		throw new IllegalArgumentException();
       	
		for (int x : new Range(icon.getWidth()))
			for (int y : new Range(icon.getHeight()))
			{				
				// I use the distance from the target color here. This is a cheap hack. The problem
				// is that I need 2 types of transparency: I need regular transparency, and I need 
				// transparency that draws the background image without anything that has already
				// been drawn to the map.
				Color color = new Color(icon.getRGB(x, y));
				double distance = Math.abs(r - color.getRed()) + Math.abs(g - color.getGreen()) + 
						Math.abs(b - color.getBlue());
				if (distance < 150)
				{
					// Draw the background image to this pixel.
					try
					{
						icon.setRGB(x, y, background.getRGB(x + xLoc, y + yLoc));						
					}
					catch (IndexOutOfBoundsException e)
					{
						// Skip this pixel.
					}
				}
			}

		map.getGraphics().drawImage(icon, xLoc, yLoc, null);
	}

	private static void addHills(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
	{
        Graphics g = map.getGraphics();
        BufferedImage hill = ImageIO.read(new File("assets" + File.separator
				+ "hill.png"));
       

        for (Center c : graph.centers)
        {
         	if (c.elevation < mountainElevationThreshold && c.elevation > hillElevationThreshold
         			&& !c.water && !c.coast)
        	{
        		// Find the center's size along the x axis.
	        	double cSize = findCenterWidth(c);
           		// Scale the hill to half the size of the center. This makes hills small and somewhat
           		// isolated.
	           	cSize /= 2.0;
	           	
	           	if ((int)(cSize) > 0)
	           	{
		           	BufferedImage scaledHill = ImageHelper.scale(hill, (int)cSize);
		           	// Draw the image such that it is centered in the center of c.
		           	int x = (int) (c.loc.x - cSize/2);
		           	int y = (int) (c.loc.y - scaledHill.getHeight()/2.0);
		        	
		        	//g.drawImage(scaledHill, x, y, null);
		           	drawIconWithBackground(map, scaledHill, land, x, y);
	           	}
	        }
        }
        
        g.dispose();
	}
	
	private static void addTrees(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
	{
		// Find the average width of all Centers.
		double sum = 0;
		for (Center c : graph.centers)
		{
			sum += findCenterWidth(c);
		}
		double avgSize = sum / graph.centers.size();
		
        Graphics g = map.getGraphics();
        BufferedImage deciduousTree1 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree1.png"));
        BufferedImage deciduousTree2 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree2.png"));
        BufferedImage deciduousTree3 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree3.png"));
        List<BufferedImage> treeImages = Arrays.asList(deciduousTree1, deciduousTree2, deciduousTree3);
        
        List<GraphImpl.ColorData> treeBiomes = Arrays.asList(GraphImpl.ColorData.TEMPERATE_RAIN_FOREST);
       

        for (Center c : graph.centers)
        {
        	if (c.elevation < hillElevationThreshold && !c.water && !c.coast
        			&& treeBiomes.contains(c.biome))
        	{
        		// Find the center's size along the x axis.
	           	drawTrees(graph, map, land, treeImages, avgSize, c.loc);
	        }
        }
        
        for (Corner c : graph.corners)
        {
        	if (c.elevation < hillElevationThreshold && !c.water && !c.coast)
        	{
        		// See if a center touching this corner is a biome we draw trees with.
            	boolean isTreeBiome = false;
            	for (Center center : c.touches)
            	{
            		if (treeBiomes.contains(center.biome))
            		{
            			isTreeBiome = true;
            			break;
            		}
            	}
            	if (!isTreeBiome)
            		continue;
            	
            	// Find the corner's size along the x axis.
 	           	drawTrees(graph, map, land, treeImages, avgSize, c.loc);
	        }
        }
        
        g.dispose();
	}
	
	private static double findCenterWidth(Center c)
	{
    	Center eastMostNeighbor = Collections.max(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	Center westMostNeighbor = Collections.max(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return -Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	double cSize = Math.abs(eastMostNeighbor.loc.x - westMostNeighbor.loc.x);
       	return cSize;
	}
	
	private static void drawTrees(GraphImpl graph, BufferedImage map, BufferedImage land,
			List<BufferedImage> treeImages, double cSize, Point loc)
	{
       	// Make the tree images small.
       	double drawSize = cSize * treeScale;
       	
       	if ((int)(drawSize) > 0)
       	{
           	
           	for (int i = 0; i < numberOfTreesPerLocation; i++)
           	{
               	BufferedImage scaledTree = ImageHelper.scale(treeImages.get(r.nextInt(treeImages.size())), (int)drawSize);
	           	
	           	// Draw the image such that it is centered in the center of c.
	           	int x = (int) (loc.x - cSize/2);
	           	int y = (int) (loc.y - scaledTree.getHeight()/2.0);
	           	
	           	double sqrtSize = Math.sqrt(cSize);
	           	x += r.nextGaussian() * sqrtSize*2.0;
	           	y += r.nextGaussian() * sqrtSize*2.0;
	        	
	           	// Make sure we don't draw trees in water. I'm checking the top middle and the button middle of the tree
	           	// image to make sure both aren't in water.
	           	Center center = graph.getCenterOf(x, y);
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x + scaledTree.getWidth(), y);
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x, y + scaledTree.getHeight());
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x + scaledTree.getWidth(), y + scaledTree.getHeight());
	           	if (!center.water)
	           	{
	           		//mapGraphics.drawImage(scaledTree, x, y, null);
	           		drawIconWithBackground(map, scaledTree, land, x, y);
	           	}
           	}
       	}
		
	}


}
