package cs673;

import hoten.geom.Point;
import hoten.voronoi.Center;
import hoten.voronoi.Corner;

import java.awt.Color;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.Raster;
import java.io.File;
import java.io.FileInputStream;
import java.io.FilenameFilter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;

import javax.imageio.ImageIO;

import org.apache.commons.io.FilenameUtils;
import org.jtransforms.utils.ConcurrencyUtils;

import cs673.GraphImpl.ColorData;
import util.Function;
import util.Helper;
import util.ImageHelper;
import util.ListMap;
import util.Logger;
import util.Range;
import util.Tuple2;

public class MapCreator
{
	final double mountainElevationThreshold = 0.58;
	final double hillElevationThreshold = 0.53;
	final double treeScale = 4.0/8.0;
	double meanPolygonWidth;
	// If a polygon is this number times meanPolygonWidth wide, no icon will be drawn on it.
	final double maxMeansToDraw = 5.0;
	double maxSizeToDrawIcon;
	// Max gap (in polygons) between mountains for considering them a single group. Warning:
	// there tend to be long polygons along edges, so if this value is much more than 2, 
	// mountains near the ocean may be connected despite long distances between them..
	private final int maxGapSizeInMountainClusters = 2;
	private final int maxGapBetweenBiomeGroups = 2;
	// Mountain images are scaled by this.
	private final double mountainScale = 1.0;
	// Hill images are scaled by this.
	private final double hillScale = 0.5;
	
	// All mountain ranges and smaller groups of mountains (include mountains that are alone).
	private List<Set<Center>> mountainGroups;
	
	// All mountain ranges and smaller groups of mountains extended to include nearby hills.
	private List<Set<Center>> mountainAndHillGroups;
	
	
	private List<IconDrawTask> iconsToDraw;
	
	private Random r;
	// This is a base width for determining how large to draw text and effects.
	private final double baseResolution = 1536;
	
	public MapCreator()
	{
		iconsToDraw = new ArrayList<>();
	}

	/**
	 * 
	 * @param settings
	 * @param maxResolution The maximun width and height (in pixels) at which to draw the map.
	 * This is needed for creating previews. null means draw at normal resolution.
	 * @return
	 * @throws IOException
	 */
	public BufferedImage createMap(final MapSettings settings, Dimension maxDimensions)
			throws IOException
	{		
		if (!Files.exists(Paths.get(settings.landBackgroundImage)))
			throw new IllegalArgumentException("Land background image file does not exists: " + settings.landBackgroundImage);
		if (!Files.exists(Paths.get(settings.oceanBackgroundImage)))
			throw new IllegalArgumentException("Ocean background image file does not exists: " + settings.oceanBackgroundImage);
		
		double startTime = System.currentTimeMillis();
		
		final boolean saveMasks = false;
				
						
        Logger.println("Seed: " + settings.randomSeed);
        r = new Random(settings.randomSeed);

		
		BufferedImage land;
		BufferedImage ocean;
		DimensionDouble bounds;
		if (settings.generateBackground)
		{
			bounds = new DimensionDouble(settings.generatedWidth * settings.resolution,
					settings.generatedHeight * settings.resolution);
			if (maxDimensions != null)
			{
				bounds = ImageHelper.fitDimensionsWithinBoundingBox(maxDimensions, bounds.getWidth(),
						bounds.getHeight());
			}			
			
			BufferedImage fractalBG = FractalBGGenerator.generate(
					new Random(settings.backgroundRandomSeed), settings.fractalPower, 
					(int)bounds.getWidth(), (int)bounds.getHeight(), 0.75f);
			land = ImageHelper.colorify2(fractalBG, settings.landColor);
			ocean = ImageHelper.colorify2(fractalBG, settings.oceanColor);
		}
		else
		{
			try
			{
				land = ImageIO.read(new File(settings.landBackgroundImage));
				Helper.writeImage(land, "land 0.png");
			}
			catch(IOException e)
			{
				throw new IllegalArgumentException("Cannot read land background image from " 
						+ settings.landBackgroundImage);
			}
			try
			{
				ocean = ImageIO.read(new File(settings.oceanBackgroundImage));
			}
			catch(IOException e)
			{
				throw new IllegalArgumentException("Cannot read ocean background image from " 
						+ settings.oceanBackgroundImage);
			}

			bounds = new DimensionDouble(land.getWidth()*settings.resolution, land.getHeight()*settings.resolution);
			if (maxDimensions != null)
			{
				bounds = ImageHelper.fitDimensionsWithinBoundingBox(maxDimensions, bounds.getWidth(),
						bounds.getHeight());
			}
			land = ImageHelper.scaleByWidth(land, (int)bounds.getWidth());
			Helper.writeImage(land, "land 1.png");
			ocean = ImageHelper.scaleByWidth(ocean, (int)bounds.getWidth());
		}
		


		
		double sizeMultiplyer = (bounds.getWidth() / baseResolution);
		
		
		TextDrawer textDrawer = settings.drawText ? new TextDrawer(settings, sizeMultiplyer) : null;
		
		GraphImpl graph = GraphCreator.createGraph(bounds.getWidth(), bounds.getHeight(),
				settings.worldSize, settings.edgeLandToWaterProbability, settings.centerLandToWaterProbability,
				new Random(r.nextLong()),
				sizeMultiplyer);		
		
		// Find the mean polygon width.
		meanPolygonWidth = findMeanPolygonWidth(graph);
		maxSizeToDrawIcon = meanPolygonWidth * maxMeansToDraw;

		markMountains(graph);
		markHills(graph);
		findMountainAndHillGroups(graph);

		// Draw mask for land vs ocean.
		Logger.println("Adding land.");
		BufferedImage landMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_BINARY);
		{
			Graphics2D g = landMask.createGraphics();
			graph.paint(g, false, false, false, true, true, false, false);
			if (saveMasks)
				ImageIO.write(landMask, "png", new File("land_mask_" + settings.randomSeed + "." + "png"));
		}

		BufferedImage map = null;
		{
			if (!settings.generateBackground)
			{
				Helper.writeImage(land, "land 2.png");
				land = ImageHelper.scaleByWidth(land, graph.getWidth());
				Helper.writeImage(land, "land 3.png");
			}
	
			// Combine land and ocean images.
			Helper.writeImage(land, "land 5.png");
			map = ImageHelper.maskWithColor(land, Color.black, landMask, false);
			Helper.writeImage(map, "map 1.png");
		}
		land = null;
		
		Logger.println("Creating coastlines.");
		BufferedImage coastlineMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_BINARY);
		{
			Graphics2D g = coastlineMask.createGraphics();
			graph.paint(g, false, false, false, false, false, true, false, sizeMultiplyer);
			if (saveMasks)
				ImageIO.write(coastlineMask, "png", new File("coastline_mask_" + settings.randomSeed + "." + "png"));
		}
		

		Logger.println("Creating masks for darkening land near shores and for effects in ocean along coastlines.");

		// Darken the land next to borders.
		Logger.println("Darkening land near shores.");
		{
			BufferedImage landBlur;
			int blurLevel = (int) (settings.landBlur * sizeMultiplyer);
			if (blurLevel == 0)
			{
				landBlur = new BufferedImage(map.getWidth(), map.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
			}
			else
			{
				float[][] kernel = ImageHelper.createGaussianKernel(blurLevel);
				landBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
				ImageHelper.maximizeContrastGrayscale(landBlur);
				// Remove the land blur from the ocean side of the borders.
				landBlur = ImageHelper.maskWithColor(landBlur, Color.black, landMask, false);
			}

			map = ImageHelper.maskWithColor(map, settings.landBlurColor, landBlur, true);
			if (saveMasks)
				ImageIO.write(landBlur, "png", new File("land_blur_" + settings.randomSeed + "." + "png"));
		}

		// Store the current version of the map for a background when drawing icons later.
		BufferedImage landBackground = ImageHelper.deepCopy(map);
		
		// Add rivers.
		Logger.println("Adding rivers.");
		BufferedImage riverMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
		{
			Graphics2D g = riverMask.createGraphics();
			// Draw rivers thin.
			graph.paint(g, false, false, false, false, false, false, true, sizeMultiplyer/2.0);
			map = ImageHelper.maskWithColor(map, settings.riverColor, riverMask, true);
			if (saveMasks)
				ImageIO.write(riverMask, "png", new File("river_mask_" + settings.randomSeed + "." + "png"));
		}
	
		Logger.println("Adding mountains and hills.");
		addMountainsAndHills(graph);

		Logger.println("Adding sand dunes.");
		addSandDunes(graph);
		
		Logger.println("Adding trees.");
		addTrees(graph);
		
		Logger.println("Drawing all icons.");
		drawAllIcons(map, landBackground);
		
		Logger.println("Drawing ocean.");
		{
			if (!settings.generateBackground)
			{
				ocean = ImageHelper.scaleByWidth(ocean, graph.getWidth());
			}
			if (ocean.getWidth() != graph.getWidth() || ocean.getHeight() != graph.getHeight())
			{
				throw new IllegalArgumentException("The given ocean background image does not"
						+ " have the same aspect ratio as the given land background image.");
			}

			// Needed for drawing text.
			landBackground = ImageHelper.maskWithImage(landBackground, ocean, landMask);
			
			map = ImageHelper.maskWithImage(map, ocean, landMask);
			ocean = null;
		}
		
		Logger.println("Adding effects to ocean along coastlines.");
		{
			BufferedImage oceanBlur;
			int blurLevel = (int) (settings.oceanEffects * sizeMultiplyer);
			if (blurLevel == 0)
			{
				oceanBlur = new BufferedImage(map.getWidth(), map.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
			}
			else
			{
				float[][] kernel;
				if (settings.addWavesToOcean)
				{
					kernel = ImageHelper.createPositiveSincKernel(blurLevel, 1.0 / sizeMultiplyer);
				} else
				{
					kernel = ImageHelper.createGaussianKernel((int) (settings.oceanEffects * sizeMultiplyer));
				}
				oceanBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
				ImageHelper.maximizeContrastGrayscale(oceanBlur);
				// Remove the ocean blur from the land side of the borders.
				oceanBlur = ImageHelper.maskWithColor(oceanBlur, Color.black, landMask, true);
			}
				
			if (saveMasks)
				ImageIO.write(oceanBlur, "png", new File("ocean_blur_" + settings.randomSeed + "." + "png"));
			map = ImageHelper.maskWithColor(map, settings.oceanEffectsColor, oceanBlur, true);
			landBackground = ImageHelper.maskWithColor(landBackground, settings.oceanEffectsColor, oceanBlur, true);
		}
		coastlineMask = null;
		
		// Draw coast lines.
		{
			Graphics2D g = map.createGraphics();
			g.setColor(settings.coastlineColor);
			graph.drawCoastline(g, sizeMultiplyer);
		}
		{
			Graphics2D g = landBackground.createGraphics();
			g.setColor(settings.coastlineColor);
			graph.drawCoastline(g, sizeMultiplyer);
		}
		
		if (settings.drawText)
		{
			Logger.println("Adding text.");
			// Add the rivers to landBackground so that the text doesn't erase them.
			landBackground = ImageHelper.maskWithColor(landBackground, settings.riverColor, riverMask, true);

			textDrawer.drawText(graph, map, landBackground, mountainGroups);
		}
		landBackground = null;

		if (settings.frayedBorder)
		{
			Logger.println("Adding frayed border.");
			BufferedImage borderMask = new BufferedImage(graph.getWidth(),
					graph.getHeight(), BufferedImage.TYPE_BYTE_BINARY);
			graph.drawBorderWhite(borderMask.createGraphics());
			if (saveMasks)
				ImageIO.write(borderMask, "png", Paths.get("border_mask_" + settings.randomSeed + ".png").toFile());

			int blurLevel = (int) (settings.frayedBorderBlurLevel * sizeMultiplyer);
			if (blurLevel > 0)
			{
				float[][] kernel = ImageHelper.createGaussianKernel(blurLevel);
				BufferedImage borderBlur = ImageHelper.convolveGrayscale(borderMask, kernel);
				ImageHelper.maximizeContrastGrayscale(borderBlur);
			
				map = ImageHelper.maskWithColor(map, settings.frayedBorderColor, borderBlur, true);

				if (saveMasks)
					ImageIO.write(borderBlur, "png", new File("border_blur_" + settings.randomSeed + "." + "png"));
			}
			map = ImageHelper.setAlphaFromMask(map, borderMask, true);
		}
		
		double elapsedTime = System.currentTimeMillis() - startTime;
		Logger.println("Total time to generate map (in seconds): " + elapsedTime / 1000.0);
		
		Logger.println("Shutting down thread pool.");
		ConcurrencyUtils.shutdownAndAwaitTermination();

		Logger.println("Done creating map.");
		
		return map;

	}
		
	private double findMeanPolygonWidth(GraphImpl graph)
	{
		double widthSum = 0;
		int count = 0;
		for (Center center : graph.centers)
		{
			double width = center.findWidth(); 
			
			if (width > 0)
			{
				count++;
				widthSum += width;
			}
		}
		
		return widthSum / count;
	}

	private void markMountains(GraphImpl graph)
	{
		for (Center c : graph.centers)
		{
			if (c.elevation > mountainElevationThreshold && !c.water
					&& !c.coast && !c.border && c.findWidth() < maxSizeToDrawIcon)
			{
				c.mountain = true;
			}
		}
	}

	private void markHills(GraphImpl graph)
	{
		for (Center c : graph.centers)
		{
			if (c.elevation < mountainElevationThreshold && c.elevation > hillElevationThreshold
		 			&& !c.water && !c.coast && c.findWidth() < maxSizeToDrawIcon)
				
			{
				c.hill = true;
			}
		}
	}

 
	
	/**
	 * Finds and marks mountain ranges, and groups smaller than ranges, and surrounding hills.
	 */
	private void findMountainAndHillGroups(GraphImpl graph)
	{
		mountainGroups = findCenterGroups(graph, maxGapSizeInMountainClusters, new Function<Center, Boolean>()
				{
					public Boolean apply(Center center)
					{
						return center.mountain;
					}
				});
		
		mountainAndHillGroups = findCenterGroups(graph, maxGapSizeInMountainClusters, new Function<Center, Boolean>()
		{
			public Boolean apply(Center center)
			{
				return center.mountain || center.hill;
			}
		});

		// Assign mountain group ids to each center that is in a mountain group.
		int curId = 0;
		for (Set<Center> group : mountainAndHillGroups)
		{
			for (Center c : group)
			{
				c.mountainRangeId = curId;
			}
			curId++;
		}
		
}

	/**
	 * Finds groups of centers that accepted according to a given function. A group is a set of centers
	 * for which there exists a path from any member of the set to any other such that you
	 * never have to skip over more than maxGapSize centers not accepted at once
	 * to get to that other center. If distanceThreshold > 1, the result will include those
	 * centers which connect centeres that are accepted.
	 */
	private static List<Set<Center>> findCenterGroups(GraphImpl graph, int maxGapSize,
			Function<Center, Boolean> accept)
	{
		List<Set<Center>> groups = new ArrayList<>();
		// Contains all explored centers in this graph. This prevents me from making a new group
		// for every center.
		Set<Center> explored = new HashSet<>();
		for (Center center : graph.centers)
		{
			if (accept.apply(center) && !explored.contains(center))
			{
				// Do a breadth-first-search from that center, creating a new group.
				// "frontier" maps centers to their distance from a center of the desired biome. 
				// 0 means it is of the desired biome.
				Map<Center, Integer> frontier = new HashMap<>();
				frontier.put(center, 0);
				Set<Center> group = new HashSet<>();
				group.add(center);
				while (!frontier.isEmpty())
				{
					Map<Center, Integer> nextFrontier = new HashMap<>();
					for (Map.Entry<Center, Integer> entry : frontier.entrySet())
					{
						for (Center n : entry.getKey().neighbors)
						{
							if (!explored.contains(n))
							{
								if (accept.apply(n))
								{
									explored.add(n);
									group.add(n);
									nextFrontier.put(n, 0);
								}
								else if (entry.getValue() < maxGapSize)
								{
									int newDistance = entry.getValue() + 1;
									nextFrontier.put(n, newDistance);
								}
							}
						}
					}
					frontier = nextFrontier;
				}
				groups.add(group);
				
			}
		}
		
		return groups;
	}


	/**
	 * 
=	 * @param mask A gray scale image which is white where the background should be drawn, and
	 * black where the map should be drawn instead of the background. This is necessary so that
	 * when I draw an icon that is transparent (such as a hand drawn mountain), I cannot see
	 * other mountains through it.
	 */
	private void drawIconWithBackgroundAndMask(BufferedImage map, BufferedImage icon, 
			BufferedImage mask, BufferedImage background, int xCenter, int yCenter)
	{   	
    	if (map.getWidth() != background.getWidth())
    		throw new IllegalArgumentException();
       	if (map.getHeight() != background.getHeight())
    		throw new IllegalArgumentException();
       	if (mask.getWidth() != icon.getWidth())
       		throw new IllegalArgumentException("The given mask's width does not match the icon' width.");
       	if (mask.getHeight() != icon.getHeight())
       		throw new IllegalArgumentException("The given mask's height does not match the icon' height.");
       	
       	if (icon.getWidth() > maxSizeToDrawIcon)
       		return;
       	       	      	
      	int xLeft = xCenter - icon.getWidth()/2;
      	int yBottom = yCenter - icon.getHeight()/2;
      	
		Raster maskRaster = mask.getRaster();
		for (int x : new Range(icon.getWidth()))
			for (int y : new Range(icon.getHeight()))
			{
				Color iconColor = new Color(icon.getRGB(x, y), true);
				double alpha = iconColor.getAlpha() / 255.0;
				// grey level of mask at the corresponding pixel in mask.
				double maskLevel = maskRaster.getSampleDouble(x, y, 0) / 255.0;
				Color bgColor;
				Color mapColor;
				// Find the location on the background and map where this pixel will be drawn.
				int xLoc = xLeft + x;
				int yLoc = yBottom + y;
				try
				{
					bgColor = new Color(background.getRGB(xLoc, yLoc));
					mapColor = new Color(map.getRGB(xLoc, yLoc));
				}
				catch (IndexOutOfBoundsException e)
				{
					// Skip this pixel.
					continue;
				}
				
				int red = (int)(alpha * (iconColor.getRed()) + (1 - alpha) * (maskLevel * bgColor.getRed() + (1 - maskLevel) * mapColor.getRed()));
				int green = (int)(alpha * (iconColor.getGreen()) + (1 - alpha) * (maskLevel * bgColor.getGreen() + (1 - maskLevel) * mapColor.getGreen()));
				int blue = (int)(alpha * (iconColor.getBlue()) + (1 - alpha) * (maskLevel * bgColor.getBlue() + (1 - maskLevel) * mapColor.getBlue()));
				
				map.setRGB(xLoc, yLoc, new Color(red, green, blue).getRGB());
			}
	}

	/**
	 * Stores things needed to draw an icon onto the map.
	 * @author joseph
	 *
	 */
	private class IconDrawTask implements Comparable<IconDrawTask>
	{
		BufferedImage icon;
		BufferedImage mask;
		Point centerLoc;
		int scaledWidth;
		int yBottom;
		boolean needsScale;

		public IconDrawTask(BufferedImage icon, BufferedImage mask, Point centerLoc, int scaledWidth,
				boolean needsScale)
		{
			this.icon = icon;
			this.mask = mask;
			this.centerLoc = centerLoc;
			this.scaledWidth = scaledWidth;
			this.needsScale = needsScale;
			
	   		double aspectRatio = ((double)icon.getWidth())/icon.getHeight();
	   		int scaledHeight = (int)(scaledWidth/aspectRatio);
	       	yBottom = (int)(centerLoc.y + (scaledHeight/2.0));
		}
		
		public void scaleIcon()
		{
			if (needsScale)
			{
		       	icon = ImageHelper.scaleByWidth(icon, scaledWidth);
		      	mask = ImageHelper.scaleByWidth(mask, scaledWidth);
			}
		}

		@Override
		public int compareTo(IconDrawTask other)
		{
			return Integer.compare(yBottom, other.yBottom);
		}
	}
	
	/**
	 * Draws all icons in iconsToDraw. I draw all the icons at once this way so that I can sort
	 * the icons by the y-coordinate of the base of each icon. This way icons lower on the map
	 * are drawn in front of those that are higher.
	 */
	private void drawAllIcons(BufferedImage map, BufferedImage background)
	{
		Collections.sort(iconsToDraw);

//		 Scale the icons and masks in parallel.
		List<Runnable> jobs = new ArrayList<>();
		for (final IconDrawTask task : iconsToDraw)
		{
			jobs.add(new Runnable()
			{
				@Override
				public void run()
				{
			       	task.scaleIcon();
				}			
			});
		}
		Helper.processInParallel(jobs);
		
		for (final IconDrawTask task : iconsToDraw)
		{
			drawIconWithBackgroundAndMask(map, task.icon, task.mask, background, (int)task.centerLoc.x,
					(int)task.centerLoc.y);
		}		
	}


	private void addMountainsAndHills(GraphImpl graph)
	{		
        // Maps mountain range ids (the ids in the file names) to list of mountain images and their masks.
        ListMap<String, Tuple2<BufferedImage, BufferedImage>> mountainImagesById = loadIconGroups("mountain");

        // Maps mountain range ids (the ids in the file names) to list of hill images and their masks.
        // The hill image file names must use the same ids as the mountain ranges.
        ListMap<String, Tuple2<BufferedImage, BufferedImage>> hillImagesById = loadIconGroups("hill");

        // Maps from the mountainRangeId of Centers to the range id's from the mountain image file names.
        Map<Integer, String> rangeMap = new TreeMap<>();
        
        for (Set<Center> group : mountainAndHillGroups)
        {
        	for (Center c : group)
        	{
        		// Find the center's size along the x axis.
	        	double cSize = findCenterWidthBetweenNeighbors(c);
	        	
	        	String filenameRangeId = rangeMap.get(c.mountainRangeId);
	        	if ((filenameRangeId == null))
	        	{
	        		filenameRangeId =  new ArrayList<>(mountainImagesById.keySet()).get(
	        				r.nextInt(mountainImagesById.keySet().size()));
	        		rangeMap.put(c.mountainRangeId, filenameRangeId);
	        	}

	        	if (c.mountain)
	        	{        		
		        	List<Tuple2<BufferedImage, BufferedImage>> imagesInRange =
		        			mountainImagesById.get(filenameRangeId);


		        	// I'm deliberatly putting this line before checking center size so that the
		        	// random number generator is used the same no matter what resolution the map
		        	// is drawn at.
	           		int i = r.nextInt(imagesInRange.size());

	           		int scaledSize = (int)(cSize * mountainScale);

	           		// Make sure the image will be at least 1 pixel wide.
		           	if (scaledSize >= 1)
		           	{	
			           	// Draw the image such that it is centered in the center of c.
		           		iconsToDraw.add(new IconDrawTask(imagesInRange.get(i).getFirst(), 
		           				imagesInRange.get(i).getSecond(), c.loc, scaledSize, true));
		           	}
		        }
	         	else if (c.hill)
	         	{
		        	List<Tuple2<BufferedImage, BufferedImage>> imagesInGroup = 
		        			hillImagesById.get(filenameRangeId);

		        	int i = r.nextInt(imagesInGroup.size());

	           		int scaledSize = (int)(cSize * hillScale);
		        	
	           		// Make sure the image will be at least 1 pixel wide.
		           	if (scaledSize >= 1)
		           	{
		           		iconsToDraw.add(new IconDrawTask(imagesInGroup.get(i).getFirst(), 
		           				imagesInGroup.get(i).getSecond(), c.loc, scaledSize, true));
		           	}
	         		
	         	}
        	}
        }
   	}
	
	private void addSandDunes(GraphImpl graph)
	{
        // Load the sand dune images.
        List<Tuple2<BufferedImage, BufferedImage>> duneImages = loadIconGroups("dune").get("sand");
        
   		List<Set<Center>> groups = findCenterGroups(graph, maxGapBetweenBiomeGroups, 
				new Function<Center, Boolean>()
				{
					public Boolean apply(Center center)
					{
						return center.biome.equals(ColorData.TEMPERATE_DESERT);
					}
				});
   		
   		// This is the probability that a temperate desert will be a dune field.
   		double duneProbabilityPerBiomeGroup = 0.6;
   		double duneProbabilityPerCenter = 0.5;
   		
   		// Find the average center width.
   		double sum = 0;
   		double count = 0;
		for (Set<Center> group : groups)
		{
			for (Center c : group)
			{
				sum += c.findWidth();
				count++;
			}
		}
		double averageWidth = sum/count;
		
		int width = (int)(averageWidth * 1.5);
		if (width == 0)
			return;
		
   		
		for (Set<Center> group : groups)
		{
			// For making sure we only draw once per corner.
//			Set<Corner> cornersDrawn = new HashSet<>();
			
			if (r.nextDouble() < duneProbabilityPerBiomeGroup)
			{
				for (Center c : group)
				{	        
					if (r.nextDouble() < duneProbabilityPerCenter)
					{
						int i = r.nextInt(duneImages.size());
						
		           		iconsToDraw.add(new IconDrawTask(duneImages.get(i).getFirst(), 
		           				duneImages.get(i).getSecond(), c.loc, width, true));
					}
				}
				
			}
		}
	}
		
	private void addTrees(GraphImpl graph)
			throws IOException
	{
		// Find the average width of all Centers.
		double sum = 0;
		for (Center c : graph.centers)
		{
			sum += findCenterWidthBetweenNeighbors(c);
		}
		double avgHeight = sum / graph.centers.size();
		
        // Load the images and masks.
        ListMap<String, Tuple2<BufferedImage, BufferedImage>> treesById = loadIconGroups("tree");
        
      	// Make the tree images small. I make them all the same height.
        int scaledHeight = (int)(avgHeight * treeScale);
       	if (scaledHeight == 0)
       	{
       		// Don't draw trees if they would all be size zero.
       		return;
       	}
        for (List<Tuple2<BufferedImage, BufferedImage>> imageGroup: treesById.values())
        {
        	for (Tuple2<BufferedImage, BufferedImage> tuple : imageGroup)
        	{
		       	tuple.setFirst(ImageHelper.scaleByHeight(tuple.getFirst(), scaledHeight));
		       	tuple.setSecond(ImageHelper.scaleByHeight(tuple.getSecond(), scaledHeight));
        	}
        }
   		

   		List<ForestType> forestTypes = new ArrayList<>();
        forestTypes.add(new ForestType(GraphImpl.ColorData.TEMPERATE_RAIN_FOREST, 0.5, 1.0,
        		treesById.get("deciduous")));
        forestTypes.add(new ForestType(GraphImpl.ColorData.TAIGA, 1.0, 1.0, treesById.get("pine")));
        forestTypes.add(new ForestType(GraphImpl.ColorData.SHRUBLAND, 1.0, 1.0, treesById.get("pine")));
        forestTypes.add(new ForestType(GraphImpl.ColorData.HIGH_TEMPERATE_DECIDUOUS_FOREST, 1.0, 0.25, treesById.get("pine")));
        forestTypes.add(new ForestType(GraphImpl.ColorData.HIGH_TEMPERATE_DESERT, 1.0/8.0, 0.1,
        		treesById.get("cacti")));
 
        // Store which corners have had trees drawn so that I don't draw them multiple times.
        boolean[] cornersWithTreesDrawn = new boolean[graph.corners.size()];
        
        for (final ForestType forest : forestTypes)
        {
        	if (forest.biomeFrequency != 1.0)
        	{
        		List<Set<Center>> groups = findCenterGroups(graph, maxGapBetweenBiomeGroups, 
        				new Function<Center, Boolean>()
        				{
        					public Boolean apply(Center center)
        					{
        						return center.biome.equals(forest.biome);
        					}
        				});
        		for (Set<Center> group : groups)
        		{
        			if (r.nextDouble() < forest.biomeFrequency)
        			{
        				for (Center c : group)
        				{	        	
         					drawTreesAtCenterAndCorners(graph, forest, avgHeight,
         							cornersWithTreesDrawn, c);
        				}
        			}
        		}
        	}
        }
 
        // Process forest types that don't use biome groups separately for efficiency.
        for (Center c : graph.centers)
        {
    		for (ForestType forest : forestTypes)
    		{
    			if (forest.biomeFrequency == 1.0)
    			{		
        			if (forest.biome.equals(c.biome))
        			{
        				drawTreesAtCenterAndCorners(graph, forest, avgHeight, 
        						cornersWithTreesDrawn, c);
        			}
    			}
      			
 	        }
        }
	}

	private void drawTreesAtCenterAndCorners(GraphImpl graph,
			ForestType forest, double avgCenterHeight, boolean[] cornersWithTreesDrawn, Center center)
	{
    	if (center.biome == forest.biome && center.elevation < mountainElevationThreshold 
    			&& !center.water && !center.coast)
    	{
			drawTrees(graph, forest.imagesAndMasks, avgCenterHeight, center.loc, forest.density);
				
			// Draw trees at the neighboring corners too.
			for (Corner corner : center.corners)
			{
				if (!cornersWithTreesDrawn[corner.index])
				{
					drawTrees(graph, forest.imagesAndMasks, avgCenterHeight, corner.loc,
							forest.density);
					cornersWithTreesDrawn[corner.index] = true;
				}
			}
    	}
			
	}
	
	private class ForestType
	{
		GraphImpl.ColorData biome;
		double density;
		List<Tuple2<BufferedImage, BufferedImage>> imagesAndMasks;
		double biomeFrequency;
		
		/**
		 * @param biomeProb If this is not 1.0, groups of centers of biome type "biome" will be found
		 * and each groups will have this type of forest with probability biomeProb.
		*/
		public ForestType(GraphImpl.ColorData biome, double density, double biomeFrequency, 
				List<Tuple2<BufferedImage, BufferedImage>> imagesAndMasks)
		{
			this.biome = biome;
			this.density = density;
			this.imagesAndMasks = imagesAndMasks;
			this.biomeFrequency = biomeFrequency;
		}
	};
	
	private double findCenterWidthBetweenNeighbors(Center c)
	{
    	Center eastMostNeighbor = Collections.max(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	Center westMostNeighbor = Collections.min(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	double cSize = Math.abs(eastMostNeighbor.loc.x - westMostNeighbor.loc.x);
       	return cSize;
	}

	private void drawTrees(GraphImpl graph,
			List<Tuple2<BufferedImage, BufferedImage>> imagesAndMasks, double cSize, Point loc,
			double forestDensity)
	{
		// Convert the forestDensity into an integer number of tree to draw such that the expected
		// value is forestDensity.
		double fraction = forestDensity - (int)forestDensity;
		int extra = r.nextDouble() < fraction ? 1 : 0;
		int numTrees = ((int)forestDensity) + extra;
		       	
       	for (int i = 0; i < numTrees; i++)
       	{
       		int index = r.nextInt(imagesAndMasks.size());
       		BufferedImage image = imagesAndMasks.get(index).getFirst();
       		BufferedImage mask = imagesAndMasks.get(index).getSecond();
           	     
           	// Draw the image such that it is centered in the center of c.
           	int x = (int) (loc.x);
           	int y = (int) (loc.y);
           	
           	double sqrtSize = Math.sqrt(cSize);
           	x += r.nextGaussian() * sqrtSize*2.0;
           	y += r.nextGaussian() * sqrtSize*2.0;
        	
           	// Make sure we don't draw trees in water.
           	Center center = graph.getCenterOf(x + (int)image.getWidth()/2, y + image.getHeight()/2);
           	if (center.water)
           		continue;
           	center = graph.getCenterOf(x + (int)image.getWidth()/2, y - image.getHeight()/2);
           	if (center.water)
           		continue;
           	center = graph.getCenterOf(x - (int)image.getWidth()/2, y + image.getHeight()/2);
           	if (center.water)
           		continue;
           	center = graph.getCenterOf(x - (int)image.getWidth()/2, y - image.getHeight()/2);
           	if (!center.water)
           	{
           		iconsToDraw.add(new IconDrawTask(image, mask, new Point(x, y), (int)image.getWidth(), false));	           	
           	}
       	}
		
	}
	
	/**
	 * Loads groups if icons, using iconType as a key word to filter on.
	 */
	private ListMap<String, Tuple2<BufferedImage, BufferedImage>> loadIconGroups(final String iconType)
	{
		ListMap<String, Tuple2<BufferedImage, BufferedImage>> imagesPerGroup = new ListMap<>();

		String[] filenames = new File(Paths.get("assets", "icons").toString()).list(new FilenameFilter()
		{
			@Override
			public boolean accept(File dir, String name)
			{
				return !name.contains("_mask.") && name.matches(".+_" + iconType + "\\d+\\.png");
			}
		});
		
		Arrays.sort(filenames);

		for (String filename : filenames)
		{
			Path path = Paths.get("assets", "icons", filename);
			Logger.println("Loading icon: " + path);
			BufferedImage mountain;
			BufferedImage mask;
			try
			{
				mountain = ImageIO.read(path.toFile());
				String ext = FilenameUtils.getExtension(path.toString());
				String base = FilenameUtils.getBaseName(path.toString());
				Path maskPath = Paths.get(path.getParent().toString(), base + "_mask." + ext);
				if (!Files.exists(maskPath))
				{
					// Try jpg.
					maskPath = Paths.get(path.getParent().toString(), base + "_mask.jpg");
					if (!Files.exists(maskPath))
						throw new IllegalArgumentException("Unable to find a mask for image: " + path);
				}
				mask = ImageHelper.convertToGrayscale(ImageIO.read(new File(maskPath.toString())));
			} catch (IOException e)
			{
				throw new RuntimeException(e);
			}

			String rangeId = filename.replaceAll("(.+)_" + iconType + "\\d*.png", "$1");

			imagesPerGroup.add(rangeId, new Tuple2<>(mountain, mask));
		}
		return imagesPerGroup;
	}

	public static void main(String[] args) throws IOException
	{
		if (args.length > 1)
			Logger.println("usage: MapCreator.java properties_filename");
		String propsFilename = "map_settings.properties";
		if (args.length > 0)
			propsFilename = args[0];
		Properties props = new Properties();
		props.load(new FileInputStream(propsFilename));

		MapSettings settings = new MapSettings(propsFilename);

		// settings.randomSeed = System.currentTimeMillis();

		BufferedImage map;
		MapCreator creator = new MapCreator();
		try
		{
			map = creator.createMap(settings, null);
		} catch(Exception e)
		{
			ConcurrencyUtils.shutdownAndAwaitTermination();
			throw e;
		}
		
		Path outputPath = Paths.get("map_" + settings.randomSeed + ".png");
		ImageIO.write(map, "png", outputPath.toFile());
		Logger.println("Map written to " + outputPath.toAbsolutePath());

	}

}



