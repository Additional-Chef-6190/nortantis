package cs673;

import hoten.geom.Point;
import hoten.voronoi.Center;
import hoten.voronoi.Corner;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Properties;
import java.util.Random;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.imageio.ImageIO;

import org.apache.commons.io.FilenameUtils;

import jigl.image.ImageNotSupportedException;
import util.Function0;
import util.Helper;
import util.ImageHelper;
import util.Logger;
import util.Range;

public class MapCreator
{
	final double mountainElevationThreshold = 0.6;
	final double hillElevationThreshold = 0.55;
	final double treeScale = 1.0/4.0;
	double meanPolygonWidth;
	// If a polygon is this number times meanPolygonWidth wide, no icon will be drawn on it.
	final double maxMeansToDraw = 5.0;
	double maxSizeToDrawIcon;
	
	private Random r;

	public static void main(String[] args) throws IOException,
			ImageNotSupportedException
	{				
		if (args.length > 1)
			Logger.println("usage: MapCreator.java properties_filename");	
		String propsFilename = "map_settings.properties";
		if (args.length > 0)
			propsFilename = args[0];
		Properties props = new Properties();
		props.load(new FileInputStream(propsFilename));
				
		final long seed = System.nanoTime();

		MapSettings settings = new MapSettings(propsFilename);
		MapCreator creator = new MapCreator();
		creator.createMap(settings, Paths.get("."), "png", false, seed);
	}
	
	public BufferedImage createMap(final MapSettings settings, Path outputFolder, String fileExtension,
			boolean saveMasks, long randomSeed) throws IOException
	{		
		if (!Files.exists(Paths.get(settings.landBackgroundImage)))
			throw new IllegalArgumentException("Land background image file does not exists: " + settings.landBackgroundImage);
		if (!Files.exists(Paths.get(settings.oceanBackgroundImage)))
			throw new IllegalArgumentException("Ocean background image file does not exists: " + settings.oceanBackgroundImage);
		
		double startTime = System.currentTimeMillis();
				
						
        Logger.println("seed: " + randomSeed);
        r = new Random(randomSeed);

		TextDrawer textDrawer = settings.drawText ? new TextDrawer(settings) : null;

		GraphImpl graph = GraphCreator.createGraph((int)(2048*settings.size), (int)(1152*settings.size),
				settings.scale, settings.edgeLandToWaterProbability, settings.centerLandToWaterProbability, r);
		
		// Find the mean polygon width.
		meanPolygonWidth = findMeanPolygonWidth(graph);
		maxSizeToDrawIcon = meanPolygonWidth * maxMeansToDraw;

		markMountains(graph);

		// Draw mask for land vs ocean.
		Logger.println("Adding land.");
		final BufferedImage landMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
		{
			Graphics2D g = landMask.createGraphics();
			graph.paint(g, false, false, false, true, true, false, false);
			if (saveMasks)
				ImageIO.write(landMask, fileExtension, new File("land_mask_" + randomSeed + "." + fileExtension));
		}

		BufferedImage map = null;
		{
			BufferedImage land = ImageIO.read(new File(settings.landBackgroundImage));
			land = ImageHelper.scale(land, graph.getWidth());
	
			// Combine land and ocean images.
			map = ImageHelper.maskWithColor(land, Color.black, landMask, false);
		}
		
		Logger.println("Creating coast lines.");
		final BufferedImage coastlineMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
		{
			Graphics2D g = coastlineMask.createGraphics();
			graph.paint(g, false, false, false, false, false, true, false, Math.max(1, (int) settings.size));
			if (saveMasks)
				ImageIO.write(coastlineMask, fileExtension, new File("coastline_mask_" + randomSeed + "." + fileExtension));
		}
		

		Logger.println("Creating masks for darkening land near shores and for effects in ocean along coastlines.");
		BufferedImage landBlur;
		BufferedImage oceanBlur;
		List<Future<BufferedImage>> futures = new ArrayList<Future<BufferedImage>>();
		int numThreads = Math.min(Runtime.getRuntime().availableProcessors(), 2);
//		Logger.println("Running on " + numThreads + " threads.");
		ExecutorService exService = Executors.newFixedThreadPool(numThreads);
		try
		{
			final BufferedImage mapFinal = map;
			Callable<BufferedImage> callable1 = new Callable<BufferedImage>()
			{
				@Override
				public BufferedImage call()
				{
					if (settings.landBlur == 0)
						return new BufferedImage(mapFinal.getWidth(), mapFinal.getHeight(), 
								BufferedImage.TYPE_BYTE_GRAY);
					float[][] kernel = ImageHelper.createGaussianKernel((int)(settings.landBlur * settings.size));
					BufferedImage landBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
					ImageHelper.maximizeContrastGrayscale(landBlur);
					// Remove the land blur from the ocean side of the borders.
					landBlur = ImageHelper.maskWithColor(landBlur, Color.black, landMask, false);
					return landBlur;
				}
			};
			futures.add(exService.submit(callable1));
			
			Callable<BufferedImage> callable2 = new Callable<BufferedImage>()
			{
				@Override
				public BufferedImage call()
				{
					if (settings.oceanEffects == 0)
						return new BufferedImage(mapFinal.getWidth(), mapFinal.getHeight(),
								BufferedImage.TYPE_BYTE_GRAY);
					float[][] kernel;
					if (settings.addWavesToOcean)
					{
						kernel = ImageHelper.createPositiveSincKernel((int)(settings.oceanEffects * settings.size), 1.0/settings.size);
					}
					else
					{
						kernel = ImageHelper.createGaussianKernel((int)(settings.oceanEffects * settings.size));				
					}
					BufferedImage oceanBlur = ImageHelper.convolveGrayscale(coastlineMask, kernel);
					ImageHelper.maximizeContrastGrayscale(oceanBlur);
					// Remove the ocean blur from the land side of the borders.
					// TODO Allow the user to specify ocean blur color.
					oceanBlur = ImageHelper.maskWithColor(oceanBlur, Color.black, landMask, true);	
					return oceanBlur;
				}
			};
			futures.add(exService.submit(callable2));

			try
			{
				landBlur = futures.get(0).get();
				oceanBlur = futures.get(1).get();
			}
			catch(ExecutionException e)
			{
				throw new RuntimeException(e);
			}
			catch(InterruptedException e)
			{
				throw new RuntimeException(e);
			}
		}
		finally
		{
			exService.shutdown();
		}

		// Darken the land next to borders.
		Logger.println("Darkening land near shores.");
		{
			map = ImageHelper.maskWithColor(map, settings.landBlurColor, landBlur, true);
			if (saveMasks)
				ImageIO.write(landBlur, fileExtension, new File("land_blur_" + randomSeed + "." + fileExtension));
		}

		// Store the current version of the map for a background when drawing icons later.
		BufferedImage landBackground = ImageHelper.deepCopy(map);
		
		// Add rivers.
		Logger.println("Adding rivers.");
		BufferedImage riverMask = new BufferedImage(graph.getWidth(),
				graph.getHeight(), BufferedImage.TYPE_BYTE_GRAY);
		{
			Graphics2D g = riverMask.createGraphics();
			// Draw rivers thin.
			graph.paint(g, false, false, false, false, false, false, true, settings.size/2.0);
			map = ImageHelper.maskWithColor(map, settings.riverColor, riverMask, true);
			if (saveMasks)
				ImageIO.write(riverMask, fileExtension, new File("river_mask_" + randomSeed + "." + fileExtension));
		}

		// TODO Fix river bug.
		
		// Add hills.
		Logger.println("Adding hills.");
		addHills(graph, map, landBackground);
		
		// Add mountains.
		Logger.println("Adding mountains.");
		addMountains(graph, map, landBackground);
		
		// Add trees.
		Logger.println("Adding trees.");
		addTrees(graph, map, landBackground, settings.forestDensity);
		
		
		Logger.println("Drawing ocean.");
		{
			BufferedImage ocean = ImageIO.read(new File(settings.oceanBackgroundImage));
			ocean = ImageHelper.scale(ocean, graph.getWidth());
			// Needed for drawing text.
			landBackground = ImageHelper.combineWithMask(landBackground, ocean, landMask);
			
			map = ImageHelper.combineWithMask(map, ocean, landMask);
		}
		
		Logger.println("Adding effects to ocean along coastlines.");
		{
			if (saveMasks)
				ImageIO.write(oceanBlur, fileExtension, new File("ocean_blur_" + randomSeed + "." + fileExtension));
			map = ImageHelper.maskWithColor(map, settings.oceanEffectsColor, oceanBlur, true);
			landBackground = ImageHelper.maskWithColor(landBackground, Color.black, oceanBlur, true);
		}
		
		// Draw mask for coast lines.
		map = ImageHelper.maskWithColor(map, Color.black, coastlineMask, true);
		landBackground = ImageHelper.maskWithColor(landBackground,  Color.black, coastlineMask, true);
		
		if (settings.drawText)
		{
			Logger.println("Adding text");
			// Add the rivers to landBackground so that the text doesn't erase them.
			landBackground = ImageHelper.maskWithColor(landBackground, settings.riverColor, riverMask, true);

			textDrawer.drawText(graph, map, landBackground);
		}

		if (outputFolder != null)
		{
			String outputFilename = Paths.get(outputFolder.toString(), "map_" + randomSeed 
					+ "." + fileExtension).toString();
			ImageIO.write(map, fileExtension, new File(outputFilename));
			Logger.println("Map written to " + outputFilename);
		}
		
		double elapsedTime = System.currentTimeMillis() - startTime;
		Logger.println("Total time to generate map (in seconds): " + elapsedTime / 1000.0);

		Logger.println("Done.");
		
		return map;

	}
		
	private double findMeanPolygonWidth(GraphImpl graph)
	{
		double widthSum = 0;
		int count = 0;
		for (Center center : graph.centers)
		{
			double width = center.findWidth(); 
			
			if (width > 0)
			{
				count++;
				widthSum += width;
			}
		}
		
		return widthSum / count;
	}

	private void markMountains(GraphImpl graph)
	{
		for (Center c : graph.centers)
		{
			if (c.elevation > mountainElevationThreshold && !c.water
					&& !c.coast && !c.border && c.findWidth() < maxSizeToDrawIcon)
			{
				c.mountain = true;
			}
		}
	}
		
	
//	private static void addMountains(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
//	{
//		
//        Graphics g = map.getGraphics();
////        BufferedImage mountain1 = ImageIO.read(new File("assets" + File.separator
////				+ "mountain1.png"));
////        BufferedImage mountain2 = ImageIO.read(new File("assets" + File.separator
////				+ "mountain2.png"));
////        BufferedImage mountain3 = ImageIO.read(new File("assets" + File.separator
////				+ "mountain3.png"));
////        BufferedImage mountain4 = ImageIO.read(new File("assets" + File.separator
////				+ "mountain4.png"));
////        BufferedImage mountain5 = ImageIO.read(new File("assets" + File.separator
////				+ "mountain5.png"));
////        List<BufferedImage> mountainImages = Arrays.asList(mountain1, mountain2, mountain3, mountain4,
////        		mountain5);
//  
//        BufferedImage mountain1 = ImageIO.read(new File("assets" + File.separator
// 				+ "mountain1_temp.png"));
//          List<BufferedImage> mountainImages = Arrays.asList(mountain1);
//
//
//        for (Center c : graph.centers)
//        {
//        	if (c.mountain)
//        	{        		
//        		// Find the center's size along the x axis.
//	        	double cSize = findCenterWidth(c);
//	           	
//	           	if ((int)(cSize) > 0)
//	           	{
//		           	BufferedImage scaledMountain = ImageHelper.scale(
//		           			mountainImages.get(r.nextInt(mountainImages.size())),
//		           			(int)cSize);
//		           	// Draw the image such that it is centered in the center of c.
//		           	int x = (int) (c.loc.x - cSize/2);
//		           	int y = (int) (c.loc.y - scaledMountain.getHeight()/2.0);
//		        	
//		        	//g.drawImage(scaledMountain, x, y, null);
//		           	drawIconWithBackground(map, scaledMountain, land, x, y);
//	           	}
//	        }
//        }
//        
//        g.dispose();
//	}

//	/**
//	 * Draws the given image onto the map. Wherever the icon contains the color (175, 151, 102),
//	 * the background image will be drawn instead.
//	 * @param mapGraphics
//	 * @param icon Will be mutated.
//	 * @param background
//	 */
//	private static void drawIconWithBackground(BufferedImage map, BufferedImage icon, 
//			BufferedImage background, int xLoc, int yLoc)
//	{
//		int r = 174;
//		int g = 150;
//		int b = 102;
//    	
//    	if (map.getWidth() != background.getWidth())
//    		throw new IllegalArgumentException();
//       	if (map.getHeight() != background.getHeight())
//    		throw new IllegalArgumentException();
//       	
//		for (int x : new Range(icon.getWidth()))
//			for (int y : new Range(icon.getHeight()))
//			{				
//				// I use the distance from the target color here. This is a cheap hack. The problem
//				// is that I need 2 types of transparency: I need regular transparency, and I need 
//				// transparency that draws the background image without anything that has already
//				// been drawn to the map.
//				Color color = new Color(icon.getRGB(x, y));
//				double distance = Math.abs(r - color.getRed()) + Math.abs(g - color.getGreen()) + 
//						Math.abs(b - color.getBlue());
//				if (distance < 150)
//				{
//					// Draw the background image to this pixel.
//					try
//					{
//						icon.setRGB(x, y, background.getRGB(x + xLoc, y + yLoc));						
//					}
//					catch (IndexOutOfBoundsException e)
//					{
//						// Skip this pixel.
//					}
//				}
//			}
//
//		map.getGraphics().drawImage(icon, xLoc, yLoc, null);
//	}

	private void scaleAndDrawIconWithBackground(BufferedImage map, BufferedImage icon, 
			BufferedImage background, int xCenter, int yCenter, int scaledWidth)
	{   	
    	if (map.getWidth() != background.getWidth())
    		throw new IllegalArgumentException();
       	if (map.getHeight() != background.getHeight())
    		throw new IllegalArgumentException();
       	
       	if (scaledWidth > maxSizeToDrawIcon)
       		return;
       	
       	icon = ImageHelper.deepCopy(icon);
       	
       	double xScale = ((double)scaledWidth)/icon.getWidth();
   		double aspectRatio = ((double)icon.getWidth())/icon.getHeight();
   		int scaledHeight = (int)(scaledWidth/aspectRatio);
       	double yScale = ((double)scaledHeight/icon.getHeight());
       	
		for (int x : new Range(icon.getWidth()))
			for (int y : new Range(icon.getHeight()))
			{				
				Color color = new Color(icon.getRGB(x, y), true);
				double l = (color.getRed() + color.getGreen() + color.getBlue())/(3.0*255);
				l = 1 - l;
				Color bg;
				try
				{
					// The background color pixel must be scaled and translated the same way the image will
					// be scaled and translated when drawn.
					int xLoc = xCenter + (int)((-icon.getWidth()/2 + x)*xScale) + scaledWidth/2 - scaledWidth/2;
					int yLoc = yCenter + (int)((-icon.getHeight()/2 + y)*yScale) + scaledHeight/2 - scaledHeight/2;
					bg = new Color(background.getRGB(xLoc, yLoc));
				}
				catch (IndexOutOfBoundsException e)
				{
					// Skip this pixel.
					continue;
				}
				Color mix = new Color((int)(l*color.getRed() + (1-l)*bg.getRed()), 
						(int)(l*color.getGreen() + (1-l)*bg.getGreen()),
						(int)(l*color.getBlue() + (1-l)*bg.getBlue()));
				
				// Set the alpha value to be the same as from the original pixel.
				int c = mix.getRGB();
	            int mc = (color.getAlpha() << 24) | 0x00ffffff;
	            int newcolor = c & mc;
	            mix = new Color(newcolor, true);
				
				icon.setRGB(x, y, mix.getRGB());
			}

       	BufferedImage scaledIcon = ImageHelper.scale(icon,scaledWidth);

       	map.getGraphics().drawImage(scaledIcon,
       			xCenter - scaledIcon.getWidth()/2, yCenter - scaledIcon.getHeight()/2, null);
	}

	private void addMountains(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
	{
		
        Graphics g = map.getGraphics();
        BufferedImage mountain1 = ImageIO.read(new File("assets" + File.separator
				+ "mountain1.png"));
        BufferedImage mountain2 = ImageIO.read(new File("assets" + File.separator
				+ "mountain2.png"));
        BufferedImage mountain3 = ImageIO.read(new File("assets" + File.separator
				+ "mountain3.png"));
        BufferedImage mountain4 = ImageIO.read(new File("assets" + File.separator
				+ "mountain4.png"));
        BufferedImage mountain5 = ImageIO.read(new File("assets" + File.separator
				+ "mountain5.png"));
        List<BufferedImage> mountainImages = Arrays.asList(mountain1, mountain2, mountain3, mountain4,
        		mountain5);
  

        for (Center c : graph.centers)
        {
        	if (c.mountain)
        	{        		
        		// Find the center's size along the x axis.
	        	double cSize = findCenterWidth(c);
	           	
	           	if ((int)(cSize) > 0)
	           	{
	           		BufferedImage image = mountainImages.get(r.nextInt(mountainImages.size()));
	           				
		           	// Draw the image such that it is centered in the center of c.
	        		scaleAndDrawIconWithBackground(map, image, land, (int)c.loc.x, (int)c.loc.y, (int)cSize);
	           	}
	        }
        }
        
        g.dispose();
	}

	private void addHills(GraphImpl graph, BufferedImage map, BufferedImage land) throws IOException
	{
        Graphics g = map.getGraphics();
        BufferedImage hill = ImageIO.read(new File("assets" + File.separator
				+ "hill.png"));
       

        for (Center c : graph.centers)
        {
         	if (c.elevation < mountainElevationThreshold && c.elevation > hillElevationThreshold
         			&& !c.water && !c.coast)
        	{
        		// Find the center's size along the x axis.
	        	double cSize = findCenterWidth(c);
           		// Scale the hill to half the size of the center. This makes hills small and somewhat
           		// isolated.
	           	cSize /= 2.0;
	           	
	           	if ((int)(cSize) > 0)
	           	{
		           	scaleAndDrawIconWithBackground(map, hill, land, (int)c.loc.x, (int)c.loc.y, (int)cSize);
	           	}
	        }
        }
        
        g.dispose();
	}
	
	private void addTrees(GraphImpl graph, BufferedImage map, BufferedImage land, int forestDensity)
			throws IOException
	{
		// Find the average width of all Centers.
		double sum = 0;
		for (Center c : graph.centers)
		{
			sum += findCenterWidth(c);
		}
		double avgSize = sum / graph.centers.size();
		
        Graphics g = map.getGraphics();
        BufferedImage deciduousTree1 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree1.png"));
        BufferedImage deciduousTree2 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree2.png"));
        BufferedImage deciduousTree3 = ImageIO.read(new File("assets" + File.separator
				+ "deciduous_tree3.png"));
        List<BufferedImage> treeImages = Arrays.asList(deciduousTree1, deciduousTree2, deciduousTree3); 
        
        List<GraphImpl.ColorData> treeBiomes = Arrays.asList(GraphImpl.ColorData.TEMPERATE_RAIN_FOREST);
       

        for (Center c : graph.centers)
        {
        	if (c.elevation < hillElevationThreshold && !c.water && !c.coast
        			&& treeBiomes.contains(c.biome))
        	{
        		// Find the center's size along the x axis.
	           	drawTrees(graph, map, land, treeImages, avgSize, c.loc, forestDensity);
	        }
        }
        
        for (Corner c : graph.corners)
        {
        	if (c.elevation < hillElevationThreshold && !c.water && !c.coast)
        	{
        		// See if a center touching this corner is a biome we draw trees with.
            	boolean isTreeBiome = false;
            	for (Center center : c.touches)
            	{
            		if (treeBiomes.contains(center.biome))
            		{
            			isTreeBiome = true;
            			break;
            		}
            	}
            	if (!isTreeBiome)
            		continue;
            	
            	// Find the corner's size along the x axis.
 	           	drawTrees(graph, map, land, treeImages, avgSize, c.loc, forestDensity);
	        }
        }
        
        g.dispose();
	}
	
	private double findCenterWidth(Center c)
	{
    	Center eastMostNeighbor = Collections.max(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	Center westMostNeighbor = Collections.max(c.neighbors, new Comparator<Center>()
    			{
					public int compare(Center c1, Center c2)
					{				
						return -Double.compare(c1.loc.x, c2.loc.x);
					}
    			});
       	double cSize = Math.abs(eastMostNeighbor.loc.x - westMostNeighbor.loc.x);
       	return cSize;
	}
	
	private void drawTrees(GraphImpl graph, BufferedImage map, BufferedImage land,
			List<BufferedImage> treeImages, double cSize, Point loc, int forestDensity)
	{
       	// Make the tree images small.
       	double scaledWidth = cSize * treeScale;
       	
       	if ((int)(scaledWidth) > 0)
       	{
           	
           	for (int i = 0; i < forestDensity; i++)
           	{
           		BufferedImage image = treeImages.get(r.nextInt(treeImages.size()));
//               	BufferedImage scaledTree = ImageHelper.scale(treeImages.get(r.nextInt(treeImages.size())), (int)scaledWidth);
	           	
           		double aspectRatio = ((double)image.getWidth())/image.getHeight();
           		int scaledHeight = (int)(scaledWidth/aspectRatio);
         
	           	// Draw the image such that it is centered in the center of c.
	           	int x = (int) (loc.x);
	           	int y = (int) (loc.y);
	           	
	           	double sqrtSize = Math.sqrt(cSize);
	           	x += r.nextGaussian() * sqrtSize*2.0;
	           	y += r.nextGaussian() * sqrtSize*2.0;
	        	
	           	// Make sure we don't draw trees in water.
	           	Center center = graph.getCenterOf(x + (int)scaledWidth/2, y + scaledHeight/2);
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x + (int)scaledWidth/2, y - scaledHeight/2);
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x - (int)scaledWidth/2, y + scaledHeight/2);
	           	if (center.water)
	           		continue;
	           	center = graph.getCenterOf(x - (int)scaledWidth/2, y - scaledHeight/2);
	           	if (!center.water)
	           	{
	           		scaleAndDrawIconWithBackground(map, image, land, x, y, (int)scaledWidth);
	           	}
           	}
       	}
		
	}


}
